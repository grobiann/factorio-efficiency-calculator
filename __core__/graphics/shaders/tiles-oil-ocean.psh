cbuffer EffectUniforms : register(b0)
{
    float2 _58_resolution : packoffset(c0);
    float2 _58_backgroundOffset : packoffset(c0.z);
    float _58_padding_0 : packoffset(c1);
    float _58_timeRaw : packoffset(c1.y);
    float _58_uTime : packoffset(c1.z);
    float _58_zoom : packoffset(c1.w);
    float4 _58_uSpecularLightness : packoffset(c2);
    float4 _58_uFoamColor : packoffset(c3);
    float _58_animationSpeed : packoffset(c4);
    float _58_animationScale : packoffset(c4.y);
    float _58_darkThreshold : packoffset(c4.z);
    float _58_reflectionThreshold : packoffset(c4.w);
    float _58_specularThreshold : packoffset(c5);
    float _58_daytimeAlpha : packoffset(c5.y);
    uint _58_isPuddle : packoffset(c5.z);
    float _58_lightmapAlpha : packoffset(c5.w);
    int2 _58_noiseVariations : packoffset(c6);
    int2 _58_imageVariations : packoffset(c6.z);
};

Texture2D<float4> waterMaskTexture : register(t2);
SamplerState _waterMaskTexture_sampler : register(s2);
Texture2D<float4> imageTexture : register(t4);
SamplerState _imageTexture_sampler : register(s4);
Texture2D<float4> noiseTexture : register(t3);
SamplerState _noiseTexture_sampler : register(s3);
Texture2D<float4> normalTexture : register(t6);
SamplerState _normalTexture_sampler : register(s6);
Texture2D<float4> gradientTexture : register(t5);
SamplerState _gradientTexture_sampler : register(s5);
Texture2D<float4> mask1Texture : register(t0);
SamplerState _mask1Texture_sampler : register(s0);
Texture2D<float4> mask2Texture : register(t1);
SamplerState _mask2Texture_sampler : register(s1);

static float4 gl_FragCoord;
static float4 vColor;
static float2 vUV;
static float4 fragColor;
static float4 maskUVs;
static float4 lightColor;

struct SPIRV_Cross_Input
{
    float2 vUV : TEXCOORD0;
    float4 vColor : TEXCOORD1;
    float4 maskUVs : TEXCOORD2;
    float4 gl_FragCoord : SV_Position;
};

struct SPIRV_Cross_Output
{
    float4 fragColor : SV_Target0;
    float4 lightColor : SV_Target1;
};

static float time;
static float imageTexScale;
static float4 waterColour;

float2 random2(float2 st)
{
    float2 s = float2(dot(st, float2(12.345600128173828125f, 34.141498565673828125f)), dot(st, float2(42.21540069580078125f, 15.285400390625f)));
    return frac(sin(s) * 45678.8984375f);
}

float2 getRandomVariationUV(float2 uv, float2 variations)
{
    float2 fUV = frac(uv);
    float2 iUV = floor(uv);
    float2 param = iUV;
    float2 r = floor(random2(param) * variations);
    float2 size = 1.0f.xx / variations;
    float2 finalUV = (fUV * size) + (r * size);
    return finalUV;
}

float4 fetchImageTexture2(Texture2D<float4> tex, SamplerState _tex_sampler, float2 uvA, float2 uvB)
{
    float2 uv = lerp(uvA, uvB, 0.800000011920928955078125f.xx) * 1.75f;
    float2 param = uv;
    float2 param_1 = float2(_58_imageVariations);
    return tex.Sample(_tex_sampler, getRandomVariationUV(param, param_1));
}

float2 PanningUvs(float2 uv, float speedX, float speedY)
{
    float2 uvDist = uv;
    uvDist.x += sin((time * 1000.0f) / speedX);
    uvDist.y += sin((time * 1000.0f) / speedY);
    uvDist = float2(uvDist.x, uvDist.y);
    return uvDist;
}

float3 overlay(float3 image_1, float3 image_2, float opacity)
{
    float3 multiply = (image_1 * 2.0f) * image_2;
    float3 screen = 1.0f.xxx - (((1.0f.xxx - image_1) * 2.0f) * (1.0f.xxx - image_2));
    float threshold = step(dot(image_1, float3(0.2989999949932098388671875f, 0.58700001239776611328125f, 0.114000000059604644775390625f)), 0.5f);
    float3 result = lerp(screen, multiply, threshold.xxx);
    return lerp(image_1, result, opacity.xxx);
}

float fetchMaskTexture(Texture2D<float4> mask1Texture_1, SamplerState _mask1Texture_1_sampler, Texture2D<float4> mask2Texture_1, SamplerState _mask2Texture_1_sampler, float4 maskUVs_1, float time_1)
{
    float mask = 1.0f;
    float2 mask1UV = maskUVs_1.xy;
    float2 mask2UV = maskUVs_1.zw;
    if (mask1UV.x > (-1.0f))
    {
        mask = mask1Texture_1.Sample(_mask1Texture_1_sampler, mask1UV).x;
        if (mask2UV.x > (-1.0f))
        {
            mask *= mask2Texture_1.Sample(_mask2Texture_1_sampler, mask2UV).x;
        }
        else
        {
            if (mask2UV.x <= (-2.0f))
            {
                float timeScale = (-mask2UV.x) - 2.0f;
                float wave = (sin((time_1 * timeScale) + mask2UV.y) + 1.0f) * 0.357142865657806396484375f;
                mask = 1.0f - smoothstep(wave, wave + 0.300000011920928955078125f, 1.0f - mask);
            }
        }
    }
    return mask;
}

void frag_main()
{
    time = _58_uTime * 9.9999997473787516355514526367188e-06f;
    imageTexScale = 5.0f;
    waterColour = vColor;
    float4 foamColor = _58_uFoamColor * 10.0f;
    float4 specularLightness = _58_uSpecularLightness * 10.0f;
    float depth = _58_animationScale;
    float intensity = 0.89999997615814208984375f;
    depth *= 0.89999997615814208984375f;
    float2 uv = vUV;
    float2 noise_uv = uv * _58_reflectionThreshold;
    float speedbase = 10.0f * _58_animationSpeed;
    float Udir = speedbase / foamColor.x;
    float Vdir = speedbase / foamColor.y;
    float Udir2 = speedbase / specularLightness.x;
    float Vdir2 = speedbase / specularLightness.y;
    float3 mask = waterMaskTexture.Load(int3(int2(gl_FragCoord.xy), 0)).xyz;
    float2 param = uv;
    float2 param_1 = uv;
    float4 staticTileImage = fetchImageTexture2(imageTexture, _imageTexture_sampler, param, param_1);
    float2 param_2 = uv;
    float param_3 = Udir;
    float param_4 = Vdir;
    float2 panUVs = PanningUvs(param_2, param_3, param_4);
    float2 param_5 = uv;
    float param_6 = (-1.0f) * Vdir;
    float param_7 = (-1.0f) * Udir;
    float2 panUVs1 = PanningUvs(param_5, param_6, param_7);
    float4 noiseImage0 = noiseTexture.Sample(_noiseTexture_sampler, panUVs * _58_reflectionThreshold);
    float4 noiseImage1 = noiseTexture.Sample(_noiseTexture_sampler, (-panUVs) * _58_reflectionThreshold);
    float2 uv_1 = float2((uv.x + (noiseImage0.x * 0.02099999971687793731689453125f)) * (1.0f - (mask.y * 0.00025000001187436282634735107421875f)), (uv.y - (noiseImage1.x * 0.02099999971687793731689453125f)) * (1.0f - (mask.y * 0.00025000001187436282634735107421875f)));
    float2 param_8 = uv_1;
    float2 param_9 = uv_1;
    float4 tileImage = fetchImageTexture2(imageTexture, _imageTexture_sampler, param_8, param_9);
    float3 tileTexture = tileImage.xyz / (tileImage.w * 1.7999999523162841796875f).xxx;
    float3 param_10 = tileTexture;
    float3 param_11 = waterColour.xyz;
    float param_12 = 0.5f;
    tileTexture = overlay(param_10, param_11, param_12);
    float tileHeight = tileImage.w - mask.y;
    float2 param_13 = (uv_1 + (tileHeight / 30.0f).xx) * _58_darkThreshold;
    float param_14 = Udir2;
    float param_15 = Vdir2;
    float2 panUVs3 = PanningUvs(param_13, param_14, param_15);
    float2 param_16 = (uv_1 + (tileHeight / 30.0f).xx) * _58_darkThreshold;
    float param_17 = ((-1.0f) * Udir2) / 1.0099999904632568359375f;
    float param_18 = ((-1.0f) * Vdir2) / 1.0099999904632568359375f;
    float2 panUVs4 = PanningUvs(param_16, param_17, param_18);
    float4 noiseImage2 = noiseTexture.Sample(_noiseTexture_sampler, panUVs3);
    float4 noiseImage3 = noiseTexture.Sample(_noiseTexture_sampler, panUVs4);
    float2 param_19 = (uv_1 + (tileHeight / 20.0f).xx) * 0.60000002384185791015625f;
    float param_20 = Udir2;
    float param_21 = Vdir2;
    float2 panUVs5 = PanningUvs(param_19, param_20, param_21);
    float2 param_22 = (uv_1 + (tileHeight / 20.0f).xx) * 0.60000002384185791015625f;
    float param_23 = ((-1.0f) * Udir2) / 1.0099999904632568359375f;
    float param_24 = ((-1.0f) * Vdir2) / 1.0099999904632568359375f;
    float2 panUVs6 = PanningUvs(param_22, param_23, param_24);
    float4 noiseImage4 = noiseTexture.Sample(_noiseTexture_sampler, panUVs5);
    float4 noiseImage5 = noiseTexture.Sample(_noiseTexture_sampler, panUVs6);
    float gaussianNoise = noiseImage0.x;
    float detailNoise = noiseImage4.y * noiseImage5.y;
    float maskNoise = noiseImage2.z * noiseImage3.y;
    mask *= (detailNoise.xxx + (mask * 0.100000001490116119384765625f));
    float3 tileTexturedebug = tileTexture;
    float2 param_25 = uv_1;
    float2 param_26 = uv_1;
    float4 tileNormal = fetchImageTexture2(normalTexture, _normalTexture_sampler, param_25, param_26);
    float3 tileHighlight = clamp(pow(tileNormal.xyz, 1.2000000476837158203125f.xxx), 0.0f.xxx, 1.0f.xxx);
    float tileHighlightMask = clamp(pow(noiseImage0.x * 2.0f, 4.0f), 0.0f, 1.0f);
    tileTexture = lerp(tileTexture + tileHighlight, tileTexture, (1.0f - (clamp(tileHighlightMask, 0.0f, 1.0f) * 0.5f)).xxx);
    float3 param_27 = detailNoise.xxx;
    float3 param_28 = pow(tileHeight + (mask.y * 10.0f), 1.0f).xxx;
    float param_29 = 0.0f;
    detailNoise = overlay(param_27, param_28, param_29).x;
    float oilMask = (1.5f * lerp(clamp(1.0f - tileHeight, 0.0f, 1.0f) - clamp(tileHeight, 0.0f, 1.0f), 1.0f - tileHeight, 0.89999997615814208984375f)) + (mask.y * 10.0f);
    oilMask = lerp(oilMask * pow(maskNoise, 1.0f), oilMask, 0.0f);
    float3 gradientImage = pow(gradientTexture.Sample(_gradientTexture_sampler, float2(detailNoise, 10.0f) * 5.0f).xyz, 1.0f.xxx);
    float3 param_30 = tileTexture;
    float3 param_31 = gradientImage;
    float param_32 = clamp(oilMask * 2.0f, 0.0f, 1.0f) / _58_animationScale;
    float4 finalColor = float4(lerp(overlay(param_30, param_31, param_32), tileTexture, 0.0f.xxx), 1.0f);
    fragColor = finalColor;
    float4 param_33 = maskUVs;
    float param_34 = _58_timeRaw;
    fragColor *= fetchMaskTexture(mask1Texture, _mask1Texture_sampler, mask2Texture, _mask2Texture_sampler, param_33, param_34);
    lightColor = float4(0.0f, 0.0f, 0.0f, fragColor.w * _58_lightmapAlpha);
}

SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
{
    gl_FragCoord = stage_input.gl_FragCoord;
    gl_FragCoord.w = 1.0 / gl_FragCoord.w;
    vColor = stage_input.vColor;
    vUV = stage_input.vUV;
    maskUVs = stage_input.maskUVs;
    frag_main();
    SPIRV_Cross_Output stage_output;
    stage_output.fragColor = fragColor;
    stage_output.lightColor = lightColor;
    return stage_output;
}
