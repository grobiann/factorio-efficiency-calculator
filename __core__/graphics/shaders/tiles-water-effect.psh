cbuffer EffectUniforms : register(b0)
{
    float2 _216_resolution : packoffset(c0);
    float2 _216_backgroundOffset : packoffset(c0.z);
    float _216_padding_0 : packoffset(c1);
    float _216_timeRaw : packoffset(c1.y);
    float _216_time : packoffset(c1.z);
    float _216_zoom : packoffset(c1.w);
    float4 _216_specularLightness : packoffset(c2);
    float4 _216_foamColor : packoffset(c3);
    float _216_animationSpeed : packoffset(c4);
    float _216_animationScale : packoffset(c4.y);
    float _216_darkThreshold : packoffset(c4.z);
    float _216_reflectionThreshold : packoffset(c4.w);
    float _216_specularThreshold : packoffset(c5);
    float _216_daytimeAlpha : packoffset(c5.y);
    uint _216_isPuddle : packoffset(c5.z);
    float _216_lightmapAlpha : packoffset(c5.w);
    int2 _216_noiseVariations : packoffset(c6);
    int2 _216_imageVariations : packoffset(c6.z);
};

Texture2D<float4> waterNoiseTexture : register(t3);
SamplerState _waterNoiseTexture_sampler : register(s3);
Texture2D<float4> mask1Texture : register(t0);
SamplerState _mask1Texture_sampler : register(s0);
Texture2D<float4> mask2Texture : register(t1);
SamplerState _mask2Texture_sampler : register(s1);
Texture2D<float4> waterMaskTexture : register(t2);
SamplerState _waterMaskTexture_sampler : register(s2);

static float4 gl_FragCoord;
static float4 maskUVs;
static float2 vUV;
static float4 vColor;
static float4 fragColor;
static float4 lightColor;

struct SPIRV_Cross_Input
{
    float2 vUV : TEXCOORD0;
    float4 vColor : TEXCOORD1;
    float4 maskUVs : TEXCOORD2;
    float4 gl_FragCoord : SV_Position;
};

struct SPIRV_Cross_Output
{
    float4 fragColor : SV_Target0;
    float4 lightColor : SV_Target1;
};

float fetchMaskTexture(Texture2D<float4> mask1Texture_1, SamplerState _mask1Texture_1_sampler, Texture2D<float4> mask2Texture_1, SamplerState _mask2Texture_1_sampler, float4 maskUVs_1, float time)
{
    float mask = 1.0f;
    float2 mask1UV = maskUVs_1.xy;
    float2 mask2UV = maskUVs_1.zw;
    if (mask1UV.x > (-1.0f))
    {
        mask = mask1Texture_1.Sample(_mask1Texture_1_sampler, mask1UV).x;
        if (mask2UV.x > (-1.0f))
        {
            mask *= mask2Texture_1.Sample(_mask2Texture_1_sampler, mask2UV).x;
        }
        else
        {
            if (mask2UV.x <= (-2.0f))
            {
                float timeScale = (-mask2UV.x) - 2.0f;
                float wave = (sin((time * timeScale) + mask2UV.y) + 1.0f) * 0.357142865657806396484375f;
                mask = 1.0f - smoothstep(wave, wave + 0.300000011920928955078125f, 1.0f - mask);
            }
        }
    }
    return mask;
}

float noise_func(float2 uv)
{
    return waterNoiseTexture.Sample(_waterNoiseTexture_sampler, uv).x;
}

float2 mul(float2 v, float2x2 m)
{
    return mul(m, v);
}

float2 rotate(inout float2 uv)
{
    float2 param = uv * 2.0f;
    uv += (noise_func(param) * 0.0199999995529651641845703125f).xx;
    float angle = 3.0f;
    float sinRot = sin(angle);
    float cosRot = cos(angle);
    float2x2 rotation = float2x2(float2(cosRot, -sinRot), float2(sinRot, cosRot));
    float2 param_1 = uv;
    float2x2 param_2 = rotation;
    return mul(param_1, param_2);
}

float fbm(inout float2 uv, float t)
{
    float f = 0.0f;
    float total = 0.0f;
    float mul_1 = 1.0f;
    for (int i = 0; i < 3; i++)
    {
        float2 param = uv + ((t * 0.0024999999441206455230712890625f) * (1.0f - mul_1)).xx;
        f += (noise_func(param) * mul_1);
        total += mul_1;
        float2 param_1 = uv * 1.10000002384185791015625f;
        float2 _196 = rotate(param_1);
        uv = _196;
        mul_1 *= 0.75f;
    }
    return f / total;
}

float4 MainPS()
{
    float4 param = maskUVs;
    float param_1 = _216_timeRaw;
    float tileTransitionMask = fetchMaskTexture(mask1Texture, _mask1Texture_sampler, mask2Texture, _mask2Texture_sampler, param, param_1);
    float2 uv = vUV;
    uv.y *= 1.414000034332275390625f;
    float2 param_2 = (sin(_216_time * _216_animationSpeed) * _216_animationScale).xx + uv;
    float param_3 = _216_time;
    float _253 = fbm(param_2, param_3);
    float value = _253 + 0.100000001490116119384765625f;
    float3 mask = waterMaskTexture.Load(int3(int2(gl_FragCoord.xy), 0)).xyz;
    float darks = 1.0f - ceil(value + _216_darkThreshold);
    float reflection = smoothstep(0.0f, _216_reflectionThreshold, ((1.0f - (value * 0.800000011920928955078125f)) - 0.60000002384185791015625f) + (mask.x * 0.25f));
    float specular = clamp(ceil((value + _216_specularThreshold) - mask.x), 1.0f, 2.0f);
    float4 color = float4(vColor.xyz * ((value + (specular * 0.189999997615814208984375f)) - (mask.z * 0.300000011920928955078125f)), vColor.w);
    color = lerp(color, color * (_216_specularLightness * (-1.0f)), (darks * 0.10999999940395355224609375f).xxxx);
    float3 color_reflect = lerp(color.xyz, (color.xyz * color.xyz) * 1.5f, clamp(reflection, 0.0f, 0.5f).xxx);
    color = float4(color_reflect, color.w);
    color *= (1.0f - mask.y);
    color = lerp(color, _216_foamColor, smoothstep(-0.3499999940395355224609375f, 0.300000011920928955078125f, mask.z - (value * 2.150000095367431640625f)).xxxx);
    return color * tileTransitionMask;
}

void frag_main()
{
    fragColor = MainPS();
    lightColor = float4(0.0f, 0.0f, 0.0f, fragColor.w * _216_lightmapAlpha);
}

SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
{
    gl_FragCoord = stage_input.gl_FragCoord;
    gl_FragCoord.w = 1.0 / gl_FragCoord.w;
    maskUVs = stage_input.maskUVs;
    vUV = stage_input.vUV;
    vColor = stage_input.vColor;
    frag_main();
    SPIRV_Cross_Output stage_output;
    stage_output.fragColor = fragColor;
    stage_output.lightColor = lightColor;
    return stage_output;
}
