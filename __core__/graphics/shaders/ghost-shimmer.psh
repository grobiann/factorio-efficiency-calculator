struct globalData
{
    float distortion1;
    float distortion2;
    float distortion12_2;
    float distortion3;
    float fineDistortion;
    float grayscale;
    float2 coord;
};

struct OverlayLayer
{
    uint shapeAndBlend;
    float cutoff;
    float2 scale;
    float4 tint;
};

struct DistortionLayer
{
    uint shape;
    float intensity;
    float2 scale;
};

static const OverlayLayer _2249 = { 720900u, 0.0f, float2(9.03999996185302734375f, 6.03999996185302734375f), float4(0.0f, 0.841000020503997802734375f, 1.0f, 0.4939999878406524658203125f) };
static const OverlayLayer _2268 = { 655361u, 0.0f, 1.0f.xx, float4(0.529411971569061279296875f, 0.2823530137538909912109375f, 0.0f, 0.078429996967315673828125f) };
static const OverlayLayer _2288 = { 196609u, -1.0f, 1.0f.xx, float4(0.117646999657154083251953125f, 0.5434830188751220703125f, 0.67451000213623046875f, 0.75686299800872802734375f) };
static const OverlayLayer _2309 = { 131076u, -0.730000019073486328125f, float2(5.69999980926513671875f, 8.27999973297119140625f), float4(1.0f, 0.0f, 0.0f, 0.995999991893768310546875f) };
static const OverlayLayer _2329 = { 65537u, -1.0f, 1.0f.xx, float4(0.09890399873256683349609375f, 0.605912029743194580078125f, 0.960784018039703369140625f, 0.16099999845027923583984375f) };
static const OverlayLayer _2350 = { 65540u, 0.0900000035762786865234375f, float2(10.0f, -7.11999988555908203125f), float4(0.0f, 1.0f, 0.087999999523162841796875f, 0.5099999904632568359375f) };
static const OverlayLayer _2368[6] = { { 720900u, 0.0f, float2(9.03999996185302734375f, 6.03999996185302734375f), float4(0.0f, 0.841000020503997802734375f, 1.0f, 0.4939999878406524658203125f) }, { 655361u, 0.0f, 1.0f.xx, float4(0.529411971569061279296875f, 0.2823530137538909912109375f, 0.0f, 0.078429996967315673828125f) }, { 196609u, -1.0f, 1.0f.xx, float4(0.117646999657154083251953125f, 0.5434830188751220703125f, 0.67451000213623046875f, 0.75686299800872802734375f) }, { 131076u, -0.730000019073486328125f, float2(5.69999980926513671875f, 8.27999973297119140625f), float4(1.0f, 0.0f, 0.0f, 0.995999991893768310546875f) }, { 65537u, -1.0f, 1.0f.xx, float4(0.09890399873256683349609375f, 0.605912029743194580078125f, 0.960784018039703369140625f, 0.16099999845027923583984375f) }, { 65540u, 0.0900000035762786865234375f, float2(10.0f, -7.11999988555908203125f), float4(0.0f, 1.0f, 0.087999999523162841796875f, 0.5099999904632568359375f) } };
static const DistortionLayer _2371 = { 1u, 1.0f, 1.0f.xx };
static const DistortionLayer _2372 = { 3u, 0.100000001490116119384765625f, float2(5.0f, 1.059999942779541015625f) };
static const DistortionLayer _2373 = { 0u, 1.0f, 1.0f.xx };
static const DistortionLayer _2374[6] = { { 1u, 1.0f, 1.0f.xx }, { 3u, 0.100000001490116119384765625f, float2(5.0f, 1.059999942779541015625f) }, { 0u, 1.0f, 1.0f.xx }, { 0u, 1.0f, 1.0f.xx }, { 0u, 1.0f, 1.0f.xx }, { 0u, 1.0f, 1.0f.xx } };

cbuffer fsConstants : register(b2)
{
    float2 _240_spriteSize : packoffset(c0);
    float _240_time : packoffset(c0.z);
    float _240_worldScale : packoffset(c0.w);
    uint _240_worldUVModulo : packoffset(c1);
    float _240_padding0_ : packoffset(c1.y);
    float _240_padding1_ : packoffset(c1.z);
    float _240_padding2_ : packoffset(c1.w);
};

cbuffer fsDistortionConstants : register(b1)
{
    float4 _1866_precomputedDistorions[512] : packoffset(c0);
};

Texture2D<float4> tex2 : register(t1);
SamplerState _tex2_sampler : register(s1);
Texture2D<float4> tex : register(t0);
SamplerState _tex_sampler : register(s0);

static float4 vTint;
static float4 vWorld;
static float4 vPos;
static float2 vRawUV;
static float2 vUV;
static float4 fragColor;

struct SPIRV_Cross_Input
{
    float2 vUV : TEXCOORD0;
    float2 vRawUV : TEXCOORD1;
    float4 vTint : TEXCOORD2;
    float4 vPos : TEXCOORD3;
    float4 vWorld : TEXCOORD4;
};

struct SPIRV_Cross_Output
{
    float4 fragColor : SV_Target0;
};

static float4 shaderTint;
static float textureUVSize;
static float shaderTransparency;

float mod(float x, float y)
{
    return x - y * floor(x / y);
}

float2 mod(float2 x, float2 y)
{
    return x - y * floor(x / y);
}

float3 mod(float3 x, float3 y)
{
    return x - y * floor(x / y);
}

float4 mod(float4 x, float4 y)
{
    return x - y * floor(x / y);
}

float3 getPrecalculatedDistortion(int index)
{
    return _1866_precomputedDistorions[index].xyz;
}

float3 getPrecalculatedNoise(float coordinateY)
{
    float distortionIndexPrecise = 512.0f * (mod(coordinateY, 32.0f) / 32.0f);
    int distortionIndexA = int(mod(floor(distortionIndexPrecise), 512.0f));
    int distortionIndexB = int(mod(ceil(distortionIndexPrecise), 512.0f));
    float weightA = (1.0f - distortionIndexPrecise) + float(distortionIndexA);
    float weightB = 1.0f - weightA;
    int param = distortionIndexA;
    int param_1 = distortionIndexB;
    return (getPrecalculatedDistortion(param) * weightA) + (getPrecalculatedDistortion(param_1) * weightB);
}

float smoothFloor(float a, float tightness)
{
    return (a - 0.5f) - (atan(((-tightness) * sin(6.28318023681640625f * a)) / (1.0f - (tightness * cos(6.28318023681640625f * a)))) / 3.141590118408203125f);
}

float smoothFloorPeriodic(float a, float period, float tightness)
{
    float param = a / period;
    float param_1 = tightness;
    return period * smoothFloor(param, param_1);
}

float2 simplexProjectTiled(float2 coord_xy)
{
    return coord_xy + float2(0.5f * coord_xy.y, 0.0f);
}

float2 simplexUnprojectTiled(float2 coord_uv)
{
    return coord_uv - float2(0.5f * coord_uv.y, 0.0f);
}

float3 permute(float3 x0, float3 p)
{
    float3 x1 = mod(x0 * p.y, p.x.xxx);
    return floor(mod((x1 + p.z.xxx) * x0, p.x.xxx));
}

float taylorInvSqrt(float r)
{
    return 1.43427431583404541015625f - (0.8537347316741943359375f * r);
}

float simplexNoise2Tiled(float2 v, float period)
{
    float2 param = v;
    float2 i = floor(simplexProjectTiled(param));
    float2 param_1 = i;
    float2 x0 = v - simplexUnprojectTiled(param_1);
    bool2 _378 = (x0.x > x0.y).xx;
    float2 i1 = float2(_378.x ? float2(1.0f, 0.0f).x : float2(0.0f, 1.0f).x, _378.y ? float2(1.0f, 0.0f).y : float2(0.0f, 1.0f).y);
    float2 param_2 = i1;
    float2 x1 = x0 - simplexUnprojectTiled(param_2);
    float2 param_3 = 1.0f.xx;
    float2 x2 = x0 - simplexUnprojectTiled(param_3);
    float2 i_0 = i;
    float2 i_1 = i + i1;
    float2 i_2 = i + 1.0f.xx;
    float3 ix = float3(i_0.x, i_1.x, i_2.x);
    float3 iy = float3(i_0.y, i_1.y, i_2.y);
    ix -= ((0.5f.xxx * iy) * floor(iy / period.xxx));
    ix = mod(ix, period.xxx);
    iy = mod(iy, period.xxx);
    float3 param_4 = iy;
    float3 param_5 = float3(289.0f, 34.0f, 1.0f);
    float3 param_6 = permute(param_4, param_5) + ix;
    float3 param_7 = float3(289.0f, 34.0f, 1.0f);
    float3 p = permute(param_6, param_7);
    float3 x = frac(p / 7.0f.xxx);
    float3 h = 0.5f.xxx - abs(x);
    float3 sx = (float3(bool3(x.x < 0.0f.xxx.x, x.y < 0.0f.xxx.y, x.z < 0.0f.xxx.z)) * 2.0f) - 1.0f.xxx;
    float3 sh = float3(bool3(h.x < 0.0f.xxx.x, h.y < 0.0f.xxx.y, h.z < 0.0f.xxx.z));
    float3 a0 = x + (sx * sh);
    float2 p0 = float2(a0.x, h.x);
    float2 p1 = float2(a0.y, h.y);
    float2 p2 = float2(a0.z, h.z);
    float param_8 = dot(p0, p0);
    p0 *= taylorInvSqrt(param_8);
    float param_9 = dot(p1, p1);
    p1 *= taylorInvSqrt(param_9);
    float param_10 = dot(p2, p2);
    p2 *= taylorInvSqrt(param_10);
    float3 g = float3(dot(p0, x0), dot(p1, x1), dot(p2, x2));
    float3 m = max(0.800000011920928955078125f.xxx - float3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0f.xxx);
    m *= m;
    return 0.5f + (10.0f * dot(m * m, g));
}

float2 distortionScanlines(float2 scale, globalData globals)
{
    float param = _240_time;
    float param_1 = 15.0f;
    float param_2 = 0.0500000007450580596923828125f;
    float param_3 = 0.5f * globals.coord.y;
    float param_4 = 0.0500000007450580596923828125f;
    float2 param_5 = float2(smoothFloorPeriodic(param, param_1, param_2) / 15.0f, smoothFloor(param_3, param_4));
    float param_6 = float(_240_worldUVModulo);
    float randomDirectionStripWide = (-1.0f) + (2.0f * simplexNoise2Tiled(param_5, param_6));
    float shimmerAmount = 2.0f * randomDirectionStripWide;
    shimmerAmount *= (globals.distortion3 * globals.distortion12_2);
    return float2(shimmerAmount, 0.0f);
}

float2 distortionSin(float2 scale, globalData globals)
{
    return float2(sin(globals.coord.y * scale.x), 0.0f);
}

float2 distortionSinMove(float2 scale, globalData globals)
{
    return float2(sin((globals.coord.y * scale.x) + (_240_time * scale.y)), 0.0f);
}

float2 smallRand(float2 co)
{
    return (float2(frac(sin(dot(co, float2(12.98980045318603515625f, 78.233001708984375f))) * 43758.546875f), frac(cos(dot(co.yx, float2(8.64947032928466796875f, 45.0970001220703125f))) * 43758.546875f)) * 2.0f) - 1.0f.xx;
}

float2 distortionBubbles(float2 scale, globalData globals)
{
    float2 cellID = floor(globals.coord * 0.25f);
    float2 fractCoord = frac(globals.coord * 0.25f);
    float dx = max(0.0f, max(0.20000000298023223876953125f - fractCoord.x, fractCoord.x - 0.800000011920928955078125f)) * 5.0f;
    float dy = max(0.0f, max(0.20000000298023223876953125f - fractCoord.y, fractCoord.y - 0.800000011920928955078125f)) * 5.0f;
    float rectIntensity = max(0.0f, 1.0f - sqrt((dx * dx) + (dy * dy)));
    float safeRange = max(1.0f, scale.y);
    float2 center = (fractCoord * 2.0f) - 1.0f.xx;
    float2 param = cellID;
    center += ((smallRand(param) * 0.5f) * scale.x);
    float param_1 = length(center * 8.0f);
    return float2((((rectIntensity * pow(2.0f, (-(param_1 - scale.y)) * (param_1 - scale.y))) * sign(-center.x)) * min(1.0f, abs(center.x / safeRange))) / safeRange, 0.0f);
}

float2 distortionBubblesMove(inout float2 scale, globalData globals)
{
    float interval = 20.0f;
    float2 param = floor(globals.coord * 0.25f);
    float2 notimerng = smallRand(param);
    float2 cellID = floor(globals.coord * 0.25f) + floor(_240_time + notimerng.x).xx;
    float2 param_1 = cellID;
    float2 rng = smallRand(param_1);
    scale.y = interval * frac(((scale.y / interval) + frac(_240_time + notimerng.x)) - 0.100000001490116119384765625f);
    float2 fractCoord = frac(globals.coord * 0.25f);
    float dx = max(0.0f, max(0.20000000298023223876953125f - fractCoord.x, fractCoord.x - 0.800000011920928955078125f)) * 5.0f;
    float dy = max(0.0f, max(0.20000000298023223876953125f - fractCoord.y, fractCoord.y - 0.800000011920928955078125f)) * 5.0f;
    float rectIntensity = max(0.0f, 1.0f - sqrt((dx * dx) + (dy * dy)));
    float safeRange = max(1.0f, scale.y);
    float2 center = (fractCoord * 2.0f) - 1.0f.xx;
    center += ((rng * 0.5f) * scale.x);
    float param_2 = length(center * 8.0f);
    return float2((((rectIntensity * pow(2.0f, (-(param_2 - scale.y)) * (param_2 - scale.y))) * sign(-center.x)) * min(1.0f, abs(center.x / safeRange))) / safeRange, 0.0f);
}

float2 distortionGlitchSquares(float2 scale, globalData globals)
{
    float2 fCoord = floor(globals.coord);
    float ftime = floor((sin(fCoord.x) + cos(fCoord.y)) + (_240_time * 0.20000000298023223876953125f));
    float2 param = float2(floor(ftime + (0.5f * globals.coord.x)), floor(ftime + (0.5f * globals.coord.y)));
    float param_1 = float(_240_worldUVModulo);
    float spatialNoise = simplexNoise2Tiled(param, param_1);
    float chaosValue = floor(spatialNoise * 2.0f);
    float2 testCoord = globals.coord + float2(chaosValue, 0.0f);
    float2 floored = floor((testCoord * scale) - (floor((testCoord * 0.5f) * scale) * 2.0f));
    bool _1765 = (floored.x - floored.y) < (-0.100000001490116119384765625f);
    bool _1775;
    if (!_1765)
    {
        _1775 = (floored.x - floored.y) > 0.100000001490116119384765625f;
    }
    else
    {
        _1775 = _1765;
    }
    bool intensity = _1775;
    float2 _1780;
    if (intensity && (spatialNoise > 0.5f))
    {
        float2 param_2 = float2((100.0f * _240_time) + (20.0f * globals.coord.x), (100.0f * _240_time) + (20.0f * globals.coord.y));
        float param_3 = float(_240_worldUVModulo);
        _1780 = float2(1.0f - (2.0f * simplexNoise2Tiled(param_2, param_3)), 0.0f);
    }
    else
    {
        _1780 = 0.0f.xx;
    }
    return _1780;
}

float2 getDistortion(uint type, float2 scale, globalData globals)
{
    switch (int(type))
    {
        case 1:
        {
            float2 param = scale;
            globalData param_1 = globals;
            return distortionScanlines(param, param_1);
        }
        case 2:
        {
            float2 param_2 = scale;
            globalData param_3 = globals;
            return distortionSin(param_2, param_3);
        }
        case 3:
        {
            float2 param_4 = scale;
            globalData param_5 = globals;
            return distortionSinMove(param_4, param_5);
        }
        case 4:
        {
            float2 param_6 = scale;
            globalData param_7 = globals;
            return distortionBubbles(param_6, param_7);
        }
        case 5:
        {
            float2 param_8 = scale;
            globalData param_9 = globals;
            float2 _1852 = distortionBubblesMove(param_8, param_9);
            return _1852;
        }
        case 6:
        {
            float2 param_10 = scale;
            globalData param_11 = globals;
            return distortionGlitchSquares(param_10, param_11);
        }
        default:
        {
            return 0.0f.xx;
        }
    }
}

float4 YCoCgToRGB(float4 ycocg, float alpha)
{
    float Y = ycocg.w;
    float scale = 1.0f / ((31.875f * ycocg.z) + 1.0f);
    float Co = (ycocg.x - 0.501960813999176025390625f) * scale;
    float Cg = (ycocg.y - 0.501960813999176025390625f) * scale;
    float R = (Y + Co) - Cg;
    float G = Y + Cg;
    float B = (Y - Co) - Cg;
    return float4(R, G, B, alpha);
}

float3 screen(float3 a, float3 b)
{
    return 1.0f.xxx - ((1.0f.xxx - a) * (1.0f.xxx - b));
}

float3 multiply(float3 a, float3 b)
{
    return a * b;
}

float overlay(float a, float b)
{
    float _611;
    if (a < 0.5f)
    {
        _611 = (2.0f * a) * b;
    }
    else
    {
        _611 = 1.0f - ((2.0f * (1.0f - a)) * (1.0f - b));
    }
    return _611;
}

float3 overlay(float3 a, float3 b)
{
    float param = a.x;
    float param_1 = b.x;
    float param_2 = a.y;
    float param_3 = b.y;
    float param_4 = a.z;
    float param_5 = b.z;
    return float3(overlay(param, param_1), overlay(param_2, param_3), overlay(param_4, param_5));
}

float3 hardLight(float3 a, float3 b)
{
    float param = b.x;
    float param_1 = a.x;
    float param_2 = b.y;
    float param_3 = a.y;
    float param_4 = b.z;
    float param_5 = a.z;
    return float3(overlay(param, param_1), overlay(param_2, param_3), overlay(param_4, param_5));
}

float softLight(float a, float b)
{
    float _679;
    if (b < 0.5f)
    {
        _679 = ((2.0f * a) * b) + ((a * a) * (1.0f - (2.0f * b)));
    }
    else
    {
        _679 = ((2.0f * a) * (1.0f - b)) + (sqrt(a) * ((2.0f * b) - 1.0f));
    }
    return _679;
}

float3 softLight(float3 a, float3 b)
{
    float param = a.x;
    float param_1 = b.x;
    float param_2 = a.y;
    float param_3 = b.y;
    float param_4 = a.z;
    float param_5 = b.z;
    return float3(softLight(param, param_1), softLight(param_2, param_3), softLight(param_4, param_5));
}

float3 colorDodge(float3 a, float3 b)
{
    return a / (1.0f.xxx - b);
}

float3 add(float3 a, float3 b)
{
    return a + b;
}

float3 divide(float3 a, float3 b)
{
    return a / b;
}

float3 colorBurn(float3 a, float3 b)
{
    return 1.0f.xxx - ((1.0f.xxx - a) / b);
}

float3 subtract(float3 a, float3 b)
{
    return a - b;
}

float difference(float a, float b)
{
    float _768;
    if (b > a)
    {
        _768 = b - a;
    }
    else
    {
        _768 = a - b;
    }
    return _768;
}

float3 difference(float3 a, float3 b)
{
    float param = a.x;
    float param_1 = b.x;
    float param_2 = a.y;
    float param_3 = b.y;
    float param_4 = a.z;
    float param_5 = b.z;
    return float3(difference(param, param_1), difference(param_2, param_3), difference(param_4, param_5));
}

float3 darken(float3 a, float3 b)
{
    return min(a, b);
}

float3 lighten(float3 a, float3 b)
{
    return max(a, b);
}

float3 applyEffect(uint type, float3 a, float3 b)
{
    switch (int(type))
    {
        case 1:
        {
            float3 param = a;
            float3 param_1 = b;
            return screen(param, param_1);
        }
        case 2:
        {
            float3 param_2 = a;
            float3 param_3 = b;
            return multiply(param_2, param_3);
        }
        case 3:
        {
            float3 param_4 = a;
            float3 param_5 = b;
            return overlay(param_4, param_5);
        }
        case 4:
        {
            float3 param_6 = a;
            float3 param_7 = b;
            return hardLight(param_6, param_7);
        }
        case 5:
        {
            float3 param_8 = a;
            float3 param_9 = b;
            return softLight(param_8, param_9);
        }
        case 6:
        {
            float3 param_10 = a;
            float3 param_11 = b;
            return colorDodge(param_10, param_11);
        }
        case 7:
        {
            float3 param_12 = a;
            float3 param_13 = b;
            return add(param_12, param_13);
        }
        case 8:
        {
            float3 param_14 = a;
            float3 param_15 = b;
            return divide(param_14, param_15);
        }
        case 9:
        {
            float3 param_16 = a;
            float3 param_17 = b;
            return colorBurn(param_16, param_17);
        }
        case 10:
        {
            float3 param_18 = a;
            float3 param_19 = b;
            return subtract(param_18, param_19);
        }
        case 11:
        {
            float3 param_20 = a;
            float3 param_21 = b;
            return difference(param_20, param_21);
        }
        case 12:
        {
            float3 param_22 = a;
            float3 param_23 = b;
            return darken(param_22, param_23);
        }
        case 13:
        {
            float3 param_24 = a;
            float3 param_25 = b;
            return lighten(param_24, param_25);
        }
        default:
        {
            return b;
        }
    }
}

uint getShapeValue(uint arg)
{
    return (arg >> uint(0)) & 65535u;
}

uint getBlendModeValue(uint arg)
{
    return (arg >> uint(16)) & 65535u;
}

float shapeGrid(float2 scale, globalData globals)
{
    float2 scaled = globals.coord * scale;
    float gridCoordX = ((2.0f * (0.300000011920928955078125f + scaled.x)) + (0.0199999995529651641845703125f * sin(5.0f * scaled.y))) + ((0.0199999995529651641845703125f * sin(((-11.0f) * _240_time) + (50.0f * scaled.y))) * sin((10.0f * _240_time) + (60.0f * scaled.y)));
    float gridCoordY = 2.0f * (0.300000011920928955078125f + scaled.y);
    return max(pow(2.0f * ((gridCoordX - floor(gridCoordX)) - 0.5f), 4.0f), pow(2.0f * ((gridCoordY - floor(gridCoordY)) - 0.5f), 4.0f));
}

float shapeCheckerboard(float2 scale, globalData globals)
{
    float2 floored = floor((globals.coord * scale) - (floor((globals.coord * 0.5f) * scale) * 2.0f));
    return abs(floored.x - floored.y);
}

float shapeScanlines(float2 scale, globalData globals)
{
    return abs(globals.fineDistortion);
}

float shapeHazard(float2 scale, globalData globals)
{
    float2 scaled = globals.coord * scale;
    return float(int(mod(scaled.x - scaled.y, 2.0f) > 1.0f));
}

float shapeDiagonalGrid(float2 scale, globalData globals)
{
    float2 scaled = globals.coord * scale;
    scaled = float2((scaled.x * 0.707099974155426025390625f) - (scaled.y * 0.707099974155426025390625f), (scaled.x * 0.707099974155426025390625f) + (scaled.y * 0.707099974155426025390625f));
    float gridCoordX = ((2.0f * (0.300000011920928955078125f + scaled.x)) + (0.0199999995529651641845703125f * sin(5.0f * scaled.y))) + ((0.0199999995529651641845703125f * sin(((-11.0f) * _240_time) + (50.0f * scaled.y))) * sin((10.0f * _240_time) + (60.0f * scaled.y)));
    float gridCoordY = 2.0f * (0.300000011920928955078125f + scaled.y);
    return max(pow(2.0f * ((gridCoordX - floor(gridCoordX)) - 0.5f), 4.0f), pow(2.0f * ((gridCoordY - floor(gridCoordY)) - 0.5f), 4.0f));
}

float shapeTriangles(float2 scale, globalData globals)
{
    float2 scaled = globals.coord * float2(scale.x, scale.x);
    float w = scale.y;
    float ymod = mod(scaled.y, 2.0f);
    bool _1120 = mod(scaled.x - scaled.y, 4.0f) > w;
    bool _1131;
    if (_1120)
    {
        _1131 = mod(scaled.x + scaled.y, 4.0f) > w;
    }
    else
    {
        _1131 = _1120;
    }
    bool _1138;
    if (_1131)
    {
        _1138 = ymod > (w / 2.0f);
    }
    else
    {
        _1138 = _1131;
    }
    bool _1146;
    if (_1138)
    {
        _1146 = ymod < (2.0f - (w / 2.0f));
    }
    else
    {
        _1146 = _1138;
    }
    return float(int(_1146));
}

float shapeGlitchSquares(float2 scale, globalData globals)
{
    float2 fCoord = floor(globals.coord);
    float ftime = floor((sin(fCoord.x) + cos(fCoord.y)) + (_240_time * 0.20000000298023223876953125f));
    float2 param = float2(floor(ftime + (0.5f * globals.coord.x)), floor(ftime + (0.5f * globals.coord.y)));
    float param_1 = float(_240_worldUVModulo);
    float spatialNoise = simplexNoise2Tiled(param, param_1);
    float chaosValue = floor(spatialNoise * 2.0f);
    float2 testCoord = globals.coord + float2(chaosValue, 0.0f);
    float2 floored = floor((testCoord * scale) - (floor((testCoord * 0.5f) * scale) * 2.0f));
    bool _1220 = (floored.x - floored.y) < (-0.100000001490116119384765625f);
    bool _1231;
    if (!_1220)
    {
        _1231 = (floored.x - floored.y) > 0.100000001490116119384765625f;
    }
    else
    {
        _1231 = _1220;
    }
    bool intensity = _1231;
    return float(int(intensity && (spatialNoise > 0.5f)));
}

float getShape(uint type, float2 scale, globalData globals)
{
    switch (int(type))
    {
        case 1:
        {
            return 1.0f;
        }
        case 2:
        {
            float2 param = scale;
            globalData param_1 = globals;
            return shapeGrid(param, param_1);
        }
        case 3:
        {
            float2 param_2 = scale;
            globalData param_3 = globals;
            return shapeCheckerboard(param_2, param_3);
        }
        case 4:
        {
            float2 param_4 = scale;
            globalData param_5 = globals;
            return shapeScanlines(param_4, param_5);
        }
        case 5:
        {
            float2 param_6 = scale;
            globalData param_7 = globals;
            return shapeHazard(param_6, param_7);
        }
        case 6:
        {
            float2 param_8 = scale;
            globalData param_9 = globals;
            return shapeDiagonalGrid(param_8, param_9);
        }
        case 7:
        {
            float2 param_10 = scale;
            globalData param_11 = globals;
            return shapeTriangles(param_10, param_11);
        }
        case 8:
        {
            float2 param_12 = scale;
            globalData param_13 = globals;
            return shapeGlitchSquares(param_12, param_13);
        }
        default:
        {
            return 0.0f;
        }
    }
}

float3 applyShapeOverlay(OverlayLayer ol, float3 baseColor, globalData globals, bool _inverse)
{
    uint param = ol.shapeAndBlend;
    uint shapeType = getShapeValue(param);
    uint param_1 = ol.shapeAndBlend;
    uint blendType = getBlendModeValue(param_1);
    bool _1310 = ol.cutoff >= 0.0f;
    bool _1319;
    if (_1310)
    {
        _1319 = globals.grayscale < ol.cutoff;
    }
    else
    {
        _1319 = _1310;
    }
    if (_1319)
    {
        return baseColor;
    }
    bool _1326 = ol.cutoff < 0.0f;
    bool _1335;
    if (_1326)
    {
        _1335 = globals.grayscale > (-ol.cutoff);
    }
    else
    {
        _1335 = _1326;
    }
    if (_1335)
    {
        return baseColor;
    }
    uint param_2 = shapeType;
    float2 param_3 = ol.scale;
    globalData param_4 = globals;
    float intensity = getShape(param_2, param_3, param_4) * ol.tint.w;
    uint param_5 = blendType;
    float3 param_6 = baseColor;
    float3 param_7 = ol.tint.xyz;
    float3 appliedColor = applyEffect(param_5, param_6, param_7);
    float _1366;
    if (_inverse)
    {
        _1366 = 1.0f - intensity;
    }
    else
    {
        _1366 = intensity;
    }
    return lerp(baseColor, appliedColor, _1366.xxx);
}

float3 applyShapeOverlay(OverlayLayer ol, float3 baseColor, globalData globals)
{
    OverlayLayer param = ol;
    float3 param_1 = baseColor;
    globalData param_2 = globals;
    bool param_3 = false;
    return applyShapeOverlay(param, param_1, param_2, param_3);
}

void frag_main()
{
    shaderTint = float4(0.225995004177093505859375f, 0.412744998931884765625f, 0.4656859934329986572265625f, 1.0f);
    textureUVSize = 12.0f / _240_spriteSize.x;
    shaderTransparency = 0.629000008106231689453125f;
    bool visualizeBorders = false;
    bool proportionalDistortion = false;
    bool rectangleBound = vTint.w > 0.0f;
    bool usesYCoCg = _240_worldScale >= 0.0f;
    float2 vExtra = (vWorld.xy / 128.0f.xx) + (vPos.xy / abs(_240_worldScale).xx);
    vExtra = mod(vExtra, float(_240_worldUVModulo).xx);
    globalData globals;
    globals.coord = vExtra;
    int tintA = int(255.0f * vTint.x);
    int tintB = int(255.0f * vTint.y);
    float4 entityTint = float4(float((tintA >> 4) & 15) / 15.0f, float((tintA >> 0) & 15) / 15.0f, float((tintB >> 4) & 15) / 15.0f, float((tintB >> 0) & 15) / 15.0f);
    float4 _1986 = entityTint;
    float3 _1988 = _1986.xyz * 1.25f;
    entityTint.x = _1988.x;
    entityTint.y = _1988.y;
    entityTint.z = _1988.z;
    entityTint.w *= 2.5f;
    float param = globals.coord.y;
    float3 noises = getPrecalculatedNoise(param);
    globals.distortion1 = noises.x;
    globals.distortion2 = noises.y;
    float distortion_12max = min(globals.distortion1, globals.distortion2);
    globals.distortion12_2 = distortion_12max * distortion_12max;
    globals.distortion3 = noises.z;
    globals.fineDistortion = globals.distortion12_2 - (globals.distortion3 * globals.distortion12_2);
    float2 stripDistortion = 0.0f.xx;
    uint param_1 = 1u;
    float2 param_2 = 1.0f.xx;
    globalData param_3 = globals;
    stripDistortion += (getDistortion(param_1, param_2, param_3) * 1.0f);
    uint param_4 = 3u;
    float2 param_5 = float2(5.0f, 1.059999942779541015625f);
    globalData param_6 = globals;
    stripDistortion += (getDistortion(param_4, param_5, param_6) * 0.100000001490116119384765625f);
    stripDistortion /= 1.10000002384185791015625f.xx;
    float R = vTint.z;
    float B = (1.0f - R) / 2.0f;
    B = (1.0f / (2.0f * R)) - 0.5f;
    float2 rawUV = vRawUV;
    rawUV.x = ((1.0f + (2.0f * B)) * rawUV.x) - B;
    float rectangleIntensity = 1.0f;
    if (rectangleBound)
    {
        float2 rectCoord = abs(rawUV - 0.5f.xx);
        float dx = max(0.0f, max(0.20000000298023223876953125f - rawUV.x, rawUV.x - 0.800000011920928955078125f)) * 5.0f;
        float dy = max(0.0f, max(0.20000000298023223876953125f - rawUV.y, rawUV.y - 0.800000011920928955078125f)) * 5.0f;
        rectangleIntensity = max(0.0f, 1.0f - sqrt((dx * dx) + (dy * dy)));
    }
    float2 transformedRawUV = rawUV + ((stripDistortion * B) * rectangleIntensity);
    bool _2129 = transformedRawUV.x <= 0.0f;
    bool _2136;
    if (!_2129)
    {
        _2136 = transformedRawUV.y <= 0.0f;
    }
    else
    {
        _2136 = _2129;
    }
    bool _2143;
    if (!_2136)
    {
        _2143 = transformedRawUV.x >= 1.0f;
    }
    else
    {
        _2143 = _2136;
    }
    bool _2150;
    if (!_2143)
    {
        _2150 = transformedRawUV.y >= 1.0f;
    }
    else
    {
        _2150 = _2143;
    }
    if (_2150)
    {
        discard;
    }
    stripDistortion *= textureUVSize;
    float2 transformedUV = vUV + (stripDistortion * rectangleIntensity);
    float alpha = tex2.Sample(_tex2_sampler, transformedUV).x;
    float4 sampledColor = tex.Sample(_tex_sampler, transformedUV);
    float4 _2182;
    if (usesYCoCg)
    {
        float4 param_7 = sampledColor;
        float param_8 = alpha;
        _2182 = YCoCgToRGB(param_7, param_8);
    }
    else
    {
        _2182 = sampledColor;
    }
    fragColor = _2182;
    float4 og = fragColor;
    float4 _2197 = fragColor;
    float3 _2199 = _2197.xyz * entityTint.xyz;
    fragColor.x = _2199.x;
    fragColor.y = _2199.y;
    fragColor.z = _2199.z;
    uint param_9 = 6u;
    float3 param_10 = fragColor.xyz;
    float3 param_11 = shaderTint.xyz;
    float3 _2215 = applyEffect(param_9, param_10, param_11);
    fragColor.x = _2215.x;
    fragColor.y = _2215.y;
    fragColor.z = _2215.z;
    fragColor.w *= shaderTransparency;
    globals.grayscale = ((0.2989999949932098388671875f * og.x) + (0.58700001239776611328125f * og.y)) + (0.114000000059604644775390625f * og.z);
    OverlayLayer param_12 = _2249;
    float3 param_13 = fragColor.xyz;
    globalData param_14 = globals;
    float3 _2256 = applyShapeOverlay(param_12, param_13, param_14);
    fragColor.x = _2256.x;
    fragColor.y = _2256.y;
    fragColor.z = _2256.z;
    OverlayLayer param_15 = _2268;
    float3 param_16 = fragColor.xyz;
    globalData param_17 = globals;
    float3 _2275 = applyShapeOverlay(param_15, param_16, param_17);
    fragColor.x = _2275.x;
    fragColor.y = _2275.y;
    fragColor.z = _2275.z;
    OverlayLayer param_18 = _2288;
    float3 param_19 = fragColor.xyz;
    globalData param_20 = globals;
    float3 _2295 = applyShapeOverlay(param_18, param_19, param_20);
    fragColor.x = _2295.x;
    fragColor.y = _2295.y;
    fragColor.z = _2295.z;
    OverlayLayer param_21 = _2309;
    float3 param_22 = fragColor.xyz;
    globalData param_23 = globals;
    float3 _2316 = applyShapeOverlay(param_21, param_22, param_23);
    fragColor.x = _2316.x;
    fragColor.y = _2316.y;
    fragColor.z = _2316.z;
    OverlayLayer param_24 = _2329;
    float3 param_25 = fragColor.xyz;
    globalData param_26 = globals;
    float3 _2336 = applyShapeOverlay(param_24, param_25, param_26);
    fragColor.x = _2336.x;
    fragColor.y = _2336.y;
    fragColor.z = _2336.z;
    OverlayLayer param_27 = _2350;
    float3 param_28 = fragColor.xyz;
    globalData param_29 = globals;
    float3 _2357 = applyShapeOverlay(param_27, param_28, param_29);
    fragColor.x = _2357.x;
    fragColor.y = _2357.y;
    fragColor.z = _2357.z;
}

SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)
{
    vTint = stage_input.vTint;
    vWorld = stage_input.vWorld;
    vPos = stage_input.vPos;
    vRawUV = stage_input.vRawUV;
    vUV = stage_input.vUV;
    frag_main();
    SPIRV_Cross_Output stage_output;
    stage_output.fragColor = fragColor;
    return stage_output;
}
